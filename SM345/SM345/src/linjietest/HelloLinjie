import java.security.Key;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.SecureRandom;
import java.security.Security;
import java.util.Arrays;
import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.spec.SecretKeySpec;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.pqc.math.linearalgebra.ByteUtils;

public class HelloLinjie {
public static void main(String[] args) {
    try {
        String json = "{\"name\":\"Marydon\",\"website\":\"http://www.cnblogs.com/Marydon20170307\"}";
        // 自定义的32位16进制密钥
        String key = "86C63180C2806ED1F47B859DE501215B";
        String cipher = Sm4Utils.encryptEcb(key, json);
        System.out.println(cipher);//05a087dc798bb0b3e80553e6a2e73c4ccc7651035ea056e43bea9d125806bf41c45b4263109c8770c48c5da3c6f32df444f88698c5c9fdb5b0055b8d042e3ac9d4e3f7cc67525139b64952a3508a7619
        System.out.println(Sm4Utils.verifyEcb(key, cipher, json));// true
        json = Sm4Utils.decryptEcb(key, cipher);
        System.out.println(json);
    } catch (Exception e) {
        e.printStackTrace();
    }
}}


/**
 * sm4加密算法工具类
 * @explain sm4加密、解密与加密结果验证
 *          可逆算法
 * @author Marydon
 * @creationTime 2018年7月6日上午11:46:59
 * @version 1.0
 * @since
 * @email marydon20170307@163.com
 */
public class Sm4Util {

    static {
        Security.addProvider(new BouncyCastleProvider());
    }

    private static final String ENCODING = "UTF-8";
    public static final String ALGORITHM_NAME = "SM4";
    // 加密算法/分组加密模式/分组填充方式
    // PKCS5Padding-以8个字节为一组进行分组加密
    // 定义分组加密模式使用：PKCS5Padding
    public static final String ALGORITHM_NAME_ECB_PADDING = "SM4/ECB/PKCS5Padding";
    // 128-32位16进制；256-64位16进制
    public static final int DEFAULT_KEY_SIZE = 128;

    /**
     * 生成ECB暗号
     * @explain ECB模式（电子密码本模式：Electronic codebook）
     * @param algorithmName
     *            算法名称
     * @param mode
     *            模式
     * @param key
     * @return
     * @throws Exception
     */
    private static Cipher generateEcbCipher(String algorithmName, int mode, byte[] key) throws Exception {
        Cipher cipher = Cipher.getInstance(algorithmName, BouncyCastleProvider.PROVIDER_NAME);
        Key sm4Key = new SecretKeySpec(key, ALGORITHM_NAME);
        cipher.init(mode, sm4Key);
        return cipher;
    }

    // 产生密钥
    /**
     * 自动生成密钥
     * @explain
     * @return
     * @throws NoSuchAlgorithmException
     * @throws NoSuchProviderException
     */
    public static byte[] generateKey() throws Exception {
        return generateKey(DEFAULT_KEY_SIZE);
    }

    /**
     * @explain
     * @param keySize
     * @return
     * @throws Exception
     */
    public static byte[] generateKey(int keySize) throws Exception {
        KeyGenerator kg = KeyGenerator.getInstance(ALGORITHM_NAME, BouncyCastleProvider.PROVIDER_NAME);
        kg.init(keySize, new SecureRandom());
        return kg.generateKey().getEncoded();
    }

    /**
     * sm4加密
     * @explain 加密模式：ECB
     *          密文长度不固定，会随着被加密字符串长度的变化而变化
     * @param hexKey
     *            16进制密钥（忽略大小写）
     * @param paramStr
     *            待加密字符串
     * @return 返回16进制的加密字符串
     * @throws Exception
     */
    public static String encryptEcb(String hexKey, String paramStr) throws Exception {
        String cipherText = "";
        // 16进制字符串-->byte[]
        byte[] keyData = ByteUtils.fromHexString(hexKey);
        // String-->byte[]
        byte[] srcData = paramStr.getBytes(ENCODING);
        // 加密后的数组
        byte[] cipherArray = encrypt_Ecb_Padding(keyData, srcData);
        // byte[]-->hexString
        cipherText = ByteUtils.toHexString(cipherArray);
        return cipherText;
    }

    /**
     * 加密模式之Ecb
     * @explain
     * @param key
     * @param data
     * @return
     * @throws Exception
     */
    public static byte[] encrypt_Ecb_Padding(byte[] key, byte[] data) throws Exception {
        Cipher cipher = generateEcbCipher(ALGORITHM_NAME_ECB_PADDING, Cipher.ENCRYPT_MODE, key);
        return cipher.doFinal(data);
    }
/**
 * sm4解密
 * @explain 解密模式：采用ECB
 * @param hexKey
 *            16进制密钥
 * @param cipherText
 *            16进制的加密字符串（忽略大小写）
 * @return 解密后的字符串
 * @throws Exception
 */
public static String decryptEcb(String hexKey, String cipherText) throws Exception {
    // 用于接收解密后的字符串
    String decryptStr = "";
    // hexString-->byte[]
    byte[] keyData = ByteUtils.fromHexString(hexKey);
    // hexString-->byte[]
    byte[] cipherData = ByteUtils.fromHexString(cipherText);
    // 解密
    byte[] srcData = decrypt_Ecb_Padding(keyData, cipherData);
    // byte[]-->String
    decryptStr = new String(srcData, ENCODING);
    return decryptStr;
}

/**
 * 解密
 * @explain
 * @param key
 * @param cipherText
 * @return
 * @throws Exception
 */
public static byte[] decrypt_Ecb_Padding(byte[] key, byte[] cipherText) throws Exception {
    Cipher cipher = generateEcbCipher(ALGORITHM_NAME_ECB_PADDING, Cipher.DECRYPT_MODE, key);
    return cipher.doFinal(cipherText);
}
/**
 * 校验加密前后的字符串是否为同一数据
 * @explain
 * @param hexKey
 *            16进制密钥（忽略大小写）
 * @param cipherText
 *            16进制加密后的字符串
 * @param paramStr
 *            加密前的字符串
 * @return 是否为同一数据
 * @throws Exception
 */
public static boolean verifyEcb(String hexKey, String cipherText, String paramStr) throws Exception {
    // 用于接收校验结果
    boolean flag = false;
    // hexString-->byte[]
    byte[] keyData = ByteUtils.fromHexString(hexKey);
    // 将16进制字符串转换成数组
    byte[] cipherData = ByteUtils.fromHexString(cipherText);
    // 解密
    byte[] decryptData = decrypt_Ecb_Padding(keyData, cipherData);
    // 将原字符串转换成byte[]
    byte[] srcData = paramStr.getBytes(ENCODING);
    // 判断2个数组是否一致
    flag = Arrays.equals(decryptData, srcData);
    return flag;
}
}

//commons-codec.jar中常用方法
一、Base64编码和解码
import org.apache.commons.codec.EncoderException;
import org.apache.commons.codec.binary.Base64;
public class TestBase64 {
    public static void main(String[] args) throws EncoderException, UnsupportedEncodingException {
        Base64 base64 = new Base64();
        String str = "AAaaa我";
        String result = base64.encodeToString(str.getBytes("UTF-8"));//编码
        System.out.println(result);
        byte[] decode = base64.decode(result.getBytes());//解码
        System.out.println(new String(decode));
    }
}
二、Hex编码和解码
import org.apache.commons.codec.DecoderException;
import org.apache.commons.codec.binary.Hex;
public class TestHex {
    public static void main(String[] args) throws DecoderException, UnsupportedEncodingException {
        String str = "test";
        /**编码*/
        String hexString = Hex.encodeHexString(str.getBytes("UTF-8"));//直接一步到位
        System.out.println(hexString);
        char[] encodeHex = Hex.encodeHex(str.getBytes(), true);//先转换成char数组，第二个参数意思是是否全部转换成小写
        System.out.println(new String(encodeHex));
        /**解码*/
        byte[] decodeHex = Hex.decodeHex(encodeHex);//char数组型的
        System.out.println(new String(decodeHex));
        byte[] decodeHex2 = Hex.decodeHex(hexString.toCharArray());//字符串类型的，该方法要求传入的是char[]
        System.out.println(new String(decodeHex2));
    }
}
三、MD5加密（MD5是不可逆算法，只能加密）
import java.io.UnsupportedEncodingException;
import org.apache.commons.codec.digest.DigestUtils;
public class TestMD5 {
    public static void main(String[] args) throws UnsupportedEncodingException {
        String str = "test";
        String md5 = DigestUtils.md5Hex(str.getBytes("UTF-8"));
        System.out.println(md5);
    }
}
四、SHA加密
import java.io.UnsupportedEncodingException;
import org.apache.commons.codec.digest.DigestUtils;
public class TestSHA {
    public static void main(String[] args) throws UnsupportedEncodingException {
        String str = "test中国";
        String sha1Hex = DigestUtils.sha1Hex(str.getBytes("UTF-8"));
        System.out.println(sha1Hex);
    }
}
五、Metaphone和Soundex
Metaphone 建立出相同的key给发音相似的单字, 比 Soundex 还要准确, 但是 Metaphone 没有固定长度, Soundex 则是固定第一个英文字加上3个数字. 这通常是用在类似音比对, 也可以用在 MP3 的软件开发
metaphone() 比 soundex() 函数更精确，因为 metaphone() 了解基本的英语发音规则

import org.apache.commons.codec.language.Metaphone;
import org.apache.commons.codec.language.RefinedSoundex;
import org.apache.commons.codec.language.Soundex;
public class TestMetaphoneAndSoundex {
    public static void main(String[] args) {
        String str = "testgggggg";
        /**Metaphone没有固定长度*/
        Metaphone metaphone = new Metaphone();
        String metaphoneEncode = metaphone.encode(str);
        System.out.println(metaphoneEncode);
        /**RefinedSoundex*/
        RefinedSoundex refinedSoundex = new RefinedSoundex();
        String refinedSoundexEncode = refinedSoundex.encode(str);
        System.out.println(refinedSoundexEncode);
        /**Soundex固定第一个英文字加上3个数字*/
        Soundex soundex = new Soundex();
        String soundexEncode = soundex.encode(str);
        System.out.println(soundexEncode);
    }
}
六、URLCodec
import org.apache.commons.codec.DecoderException;
import org.apache.commons.codec.EncoderException;
import org.apache.commons.codec.net.URLCodec;
public class TestURLCodec {
    public static void main(String[] args) throws EncoderException, DecoderException {
        String url = "http://baidu.com?name=你好";
        URLCodec codec = new URLCodec();
        String encode = codec.encode(url);
        System.out.println(encode);
        String decode = codec.decode(encode);
        System.out.println(decode);
    }
}
//除了这些还有很多算法比如HMAC等，大家可以根据需要选取,commons-codec-1.10.jar就是一个加密解码相关的jar包